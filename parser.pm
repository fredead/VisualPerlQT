
# $Id: parser.pm,v 1.3 1998/05/18 16:43:26 simon Exp simon $
# simon Tue Apr 28 22:00:21 GMT 1998
#
# parser.pl
#  Program to hold the code and parser the generation of
# the program when building becomes necassary
# May also help run a test version of the cod e???
#



package parser;

# This class inherits from QObject to allow
# it to use signals and slots since that is a nice
# way of achiveing functions
use FileHandle;
use QObject;
use slots 'editcode()', 'loadcode()', 'savecode()', 'generatecode()', 'clean()';
use signals 'saveing()', 'loading()', 'gogen()', 'genslots()', 'cleanning()';

@ISA = qw{QObject};

sub new {
	my $class = shift;
	my $self = $class->QObject::new();

	# Generate tmp file and name
	my $name = "/tmp/.pqtrad" . $$;
	$self->{name} = $name;

	# create a tempfile (Prehaps I should use the tempfile
	# routines.
	my $fh = new FileHandle;
	$self->{filehand} = $fh;
	$self->{filehand}->open(">$name");
	$self->{filehand}->close;

	

	bless ($self,$class);
	return $self;
}

# delete the file and re create it 
# basically wiping the data inside it
sub clean {
	my $self = shift;
	unlink $self->{name};
	$self->{filehand}->open(">$self->{name}");
	$self->{filehand}->close;
	emit $self->cleanning();
}


# fork an editor out on the temp file
# note must be some form the X compliant editor
# shoudl use some enviroment variable 
sub editcode {
	my $self = shift;
	# use xterm to get a graphics output then
	# execute vi on temp file. Note should probably use own editor
	# this means not dependent on other programs existing
	my @editfile = ( "/usr/X11/bin/xterm", "-e", "/bin/vi", "$self->{name}","-T","Visual Perl");

	my $pid = $$;
	if ( $pid = fork ) {
		# I am parent and fine
	}
	elsif ( defined $pid) {
		# child here therefore run editor
		exec @editfile
	} else {
		print STDERR "Cant fork: $!\n";
	}

}

# Save the code to the file
sub savecode {
	my $self = shift;
	my $fileh =  $self->{filehand};

	$fileh->open("<$self->{name}");

	# Little marker
	print "CODE START\n";
	# insert the stuff
	while (<$fileh>) 
		{
		# Insert a character at the front in order to distingsish
		# from the END and START stuf
		print " " . $_;
		}
	print "\nCODE END\n";

	$fileh->close;
	# Next bit plaese
	emit $self->saveing();
}

# load the code into the temp file
# presumes STDOUT is at the begnning of text
# to load
sub loadcode {
	my $self = shift;
	my $temp = <STDIN>;
	my $fileh =  $self->{filehand};

	$fileh->open(">$self->{name}");

	# should be at the beginning

	# go until at the end
	while ( $temp !~ /^CODE END/ )
		{
		#replace first space with nothing
		$temp =~ s/^ //;
		print $fileh $temp;
		$temp = <STDIN>;
		}

	$fileh->close;
	emit $self->loading();
}

# right lets generate some code
sub generatecode {
	my $self = shift;
	my $fileh =  $self->{filehand};

	# run perl and show some header stuff
	print "#!/usr/bin/perl\n";
	print "#Version 0.0003\n";
	print "# This program was auto generated by PerlQTRAD\n";
	print "#Copyright 1998 Simon Loader\n";
	print "#  If you need to edit this file (which you probably\n";
	print "# will) then the program is not fulling your needs\n";
	print "\n";
	print "package gui;\n";
	print "\n";
	print "# this is a use list\n";
	# just use all possible one
	print "use Qt;\n";
	print "use QWidget;\n";
	print "use QPushButton;\n";
	print "use QLabel;\n";
	print "use QToolTip;\n";
	print "use QSlider;\n";
	print "\n";
	print "#Slots to use / connections\n";
	print "use slots qw{";
	emit $self->genslots();
	print "};\n\n";

	# get widgets and let the window set itself up
	emit $self->gogen();
	
	print "\n";
	print "\n";
	# Now insert my code
	$fileh->open("<$self->{name}");
	while(<$fileh>)
		{
		print $_;
		}
	$fileh->close();

	# main part to make the program set its slef up and run

	print "\n";
	print "\n";
	print "package main;\n";
	print "use Qt;\n";
	print "\n";
	print "\$mygui = new gui;\n";
	print "\$qApp->setMainWidget(\$mygui);\n";
	print "\$mygui->show();\n";
	print "exit \$qApp->exec();\n";




}

# remeber to delete the temp file when I go
sub DESTROY {
	my $self = shift;
	unlink $self->{name};
	$self->SUPER::DESTROY();
}
